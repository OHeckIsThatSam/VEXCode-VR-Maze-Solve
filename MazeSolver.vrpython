{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      MazeSolver\n#\tAuthor:       Sam Robbins\n#\tCreated:      06/01/2025\n#   Last edited:  20/01/2025\n#\tDescription:  VEXcode VR Python Project that solves the dynamic maze.\n# \n# ------------------------------------------\n\nimport heapq\nfrom collections import defaultdict\nimport time\n\nTILE_DISTANCE = 250\nCOLUMNS = 8\nROWS = 8\nSTART_COORDS = (4, 7)\nDEST_COORDS = (3, 0)\nDIRECTIONS = [(0, -1), (1, 0), (0, 1), (-1, 0)]  # Change in coords for each cardinal direction\nglobal exit_is_found\n\n\nclass Node:\n    def __init__(self):\n        self.prev_node_x = 0\n        self.prev_node_y = 0\n        self.total_cost = float('inf')\n        self.start_cost = float('inf')  # Cost from the start of path to this cell\n        self.dest_cost = 0  # Cost from this cell to the destination\n\n\ndef map_maze():\n    \"\"\"Recursively moves the robot through the maze creating a graph representation.\"\"\"\n    # The graph is a dictionary with each key being the coordinate of a square.\n    # The list value are the coordinates of the connected nodes.\n    graph = defaultdict(list)\n\n    x = START_COORDS[0]\n    y = START_COORDS[1]\n    key = (x * 10) + y\n    \n    # The previously visited squares\n    visited = {key}\n    \n    global exit_is_found\n    exit_is_found = False\n\n    # Start square, check West then north then east for connected nodes\n    search_nodes(graph, visited, x, y)\n    \n    return graph\n\n\ndef search_nodes(graph, visited, x, y):\n    \"\"\"Recursive function that populates the given graph with all connected tiles.\"\"\"\n    # Check if the exit has been found\n    global exit_is_found\n    if not exit_is_found:\n        exit_is_found = down_eye.detect(RED)\n    \n    for i in range(4):\n        h = 90 * i\n        new_x = x + DIRECTIONS[i][0]\n        new_y = y + DIRECTIONS[i][1]\n\n        old_key = (x * 10) + y\n        new_key = (new_x * 10) + new_y\n\n        # Check if new x and y are out of bounds\n        if new_x < 0 or new_x >= 8 or new_y < 0 or new_y >= 8:\n            continue\n\n        # Check if already been to that position in ethier direction\n        if not visited.isdisjoint({new_key}):\n            continue\n\n        # Don't continue if the exit is already found\n        if exit_is_found:\n            continue\n\n        drivetrain.turn_to_heading(h, DEGREES, wait=True)\n\n        if not front_distance.get_distance(MM) < 100:\n            graph[old_key].append(new_key)\n            visited.add(new_key)\n            drivetrain.drive_for(FORWARD, TILE_DISTANCE, MM)\n            \n            search_nodes(graph, visited, new_x, new_y)\n            \n            drivetrain.turn_to_heading(h, DEGREES, wait=True)\n            drivetrain.drive_for(REVERSE, TILE_DISTANCE, MM)\n\n\ndef a_star(graph):\n    \"\"\"Uses the A* algorithm to find the shortest path in the given graph.\"\"\"\n    # Populate the list of nodes\n    nodes = [[Node() for _ in range(COLUMNS)] for _ in range(ROWS)]\n\n    x = START_COORDS[0]\n    y = START_COORDS[1]\n\n    nodes[y][x].prev_node_x = x\n    nodes[y][x].prev_node_y = y\n    nodes[y][x].total_cost = 0\n    nodes[y][x].start_cost = 0\n    nodes[y][x].dest_cost = 0\n\n    visited = set()\n    # List of nodes to search in tuple form (float, x, y) where float is the hueristic score \n    # (most likely to be closest to the goal)\n    to_search = []\n    heapq.heappush(to_search, (0.0, x, y))\n\n    has_found_dest = False\n\n    while len(to_search) > 0:\n        # Pop the node with the smallest total cost\n        node_details = heapq.heappop(to_search)\n\n        # Set x y of current node\n        x = node_details[1]\n        y = node_details[2]\n\n        # Mark node as visited\n        key = (x * 10) + y\n        visited.add(key)\n\n        # Skip if key is not in the graph (a dead end)\n        if key not in graph:\n            continue\n\n        # Search all connected nodes with current\n        for next_node_key in graph[key]:\n            # Get the next nodes x y from its key\n            next_x = math.trunc(next_node_key / 10)\n            next_y = next_node_key - (next_x * 10)\n\n            # Ignore visited nodes\n            if next_node_key in visited:\n                continue\n\n            # Check if the next node is the destination\n            if next_x == DEST_COORDS[0] and next_y == DEST_COORDS[1]:\n                nodes[next_y][next_x].prev_node_x = x\n                nodes[next_y][next_x].prev_node_y = y\n                # Create the path from the shortest nodes\n                path = create_shortest_path(nodes)\n                return path\n            else:\n                # Add cost from start (always one tile from last)\n                start_cost = nodes[y][x].start_cost + 1\n                dest_cost = distance_heuristic(next_x, next_y)\n                total_cost = start_cost + dest_cost\n\n                # Only if this nodes cost hasn't been calculated or if this paths cost is lower\n                if nodes[next_y][next_x].total_cost == float('inf') or nodes[next_y][next_x].total_cost > total_cost:\n                    # Add node to search\n                    heapq.heappush(to_search, (total_cost, next_x, next_y))\n                    # Update node\n                    nodes[next_y][next_x].prev_node_x = x\n                    nodes[next_y][next_x].prev_node_y = y\n                    nodes[next_y][next_x].total_cost = total_cost\n                    nodes[next_y][next_x].start_cost = start_cost\n                    nodes[next_y][next_x].dest_cost = dest_cost\n\n\ndef distance_heuristic(x, y):\n    \"\"\"Calculate the Euclidean Distance (diagonal straight line) from the current position to the destination.\"\"\"\n    return ((x - DEST_COORDS[0]) ** 2 + (y - DEST_COORDS[1]) ** 2) ** 0.5\n       \n        \ndef create_shortest_path(nodes):\n    \"\"\"Traverses the node map proudced by the a* algorithm and returns a list of coordinates for the robot to move to.\"\"\"\n    path = []\n    x = DEST_COORDS[0]\n    y = DEST_COORDS[1]\n\n    # Backtrack the path from the destination through the previous values \n    while not (nodes[y][x].prev_node_x == x and nodes[y][x].prev_node_y == y):\n        path.append((x, y))\n        prev_x = nodes[y][x].prev_node_x\n        prev_y = nodes[y][x].prev_node_y\n        x = prev_x\n        y = prev_y\n\n    # Reverse to get the path from source to destination\n    path.reverse()\n\n    return path\n\n\ndef follow_path(path):\n    \"\"\"Moves the robot based on the given path.\"\"\"\n    prev_x = START_COORDS[0]\n    prev_y = START_COORDS[1]\n    for coords in path:\n        x = coords[0]\n        y = coords[1]\n        # Calculate change in coords\n        change = (x - prev_x, y - prev_y)\n        # Get the index of the change in directions\n        index = DIRECTIONS.index(change)\n        # Times this by 90 Degrees to get the heading\n        h = index * 90\n\n        # Move robot\n        drivetrain.turn_to_heading(h, DEGREES, wait=True)\n        drivetrain.drive_for(FORWARD, TILE_DISTANCE, MM, wait=True)\n        \n        # Update previous position\n        prev_x = x\n        prev_y = y\n    \n\ndef main():\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    start = time.time()\n    graph = map_maze()\n    end = time.time()\n\n    total_time = end - start\n    brain.print(f'Exploration phase completed in: {end - start}s\\n\\n')\n\n    start = time.time()\n    path = a_star(graph)\n    end = time.time()\n\n    total_time += end - start\n    brain.print(f'Shortest path phase completed in: {end - start}s\\n\\n')\n\n    pen.set_pen_color(GREEN)\n    pen.move(DOWN)\n    start = time.time()\n    follow_path(path)\n    end = time.time()\n\n    total_time += end - start\n    brain.print(f'Follow path phase completed in: {end - start}\\n\\n')\n    brain.print(f'Routine complete in a total time of: {total_time}s\\n\\n')\n\n\n# VR threads â€” Do not delete\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}